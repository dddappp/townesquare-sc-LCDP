// <autogenerated>
//   This file was generated by dddappp code generator.
//   Any changes made to this file manually will be lost next time the file is regenerated.
// </autogenerated>

module townesquare_sc::user {
    use aptos_framework::account;
    use aptos_framework::event;
    use aptos_std::table::{Self, Table};
    use std::string::String;
    use townesquare_sc::genesis_account;
    use townesquare_sc::pass_object;
    friend townesquare_sc::user_create_logic;
    friend townesquare_sc::user_update_logic;
    friend townesquare_sc::user_aggregate;

    const EIdAlreadyExists: u64 = 101;
    const EDataTooLong: u64 = 102;
    const EInappropriateVersion: u64 = 103;
    const ENotInitialized: u64 = 110;

    struct Events has key {
        user_created_handle: event::EventHandle<UserCreated>,
        user_updated_handle: event::EventHandle<UserUpdated>,
    }

    struct Tables has key {
        user_table: Table<address, User>,
    }

    public fun initialize(account: &signer) {
        genesis_account::assert_genesis_account(account);

        let res_account = genesis_account::resource_account_signer();
        move_to(&res_account, Events {
            user_created_handle: account::new_event_handle<UserCreated>(&res_account),
            user_updated_handle: account::new_event_handle<UserUpdated>(&res_account),
        });

        move_to(
            &res_account,
            Tables {
                user_table: table::new(),
            },
        );

    }

    struct User has store {
        user_wallet: address,
        version: u64,
        username: String,
        profile_image: String,
        bio: String,
    }

    public fun user_wallet(user: &User): address {
        user.user_wallet
    }

    public fun version(user: &User): u64 {
        user.version
    }

    public fun username(user: &User): String {
        user.username
    }

    public(friend) fun set_username(user: &mut User, username: String) {
        assert!(std::string::length(&username) <= 66, EDataTooLong);
        user.username = username;
    }

    public fun profile_image(user: &User): String {
        user.profile_image
    }

    public(friend) fun set_profile_image(user: &mut User, profile_image: String) {
        user.profile_image = profile_image;
    }

    public fun bio(user: &User): String {
        user.bio
    }

    public(friend) fun set_bio(user: &mut User, bio: String) {
        user.bio = bio;
    }

    fun new_user(
        user_wallet: address,
        username: String,
        profile_image: String,
        bio: String,
    ): User {
        assert!(std::string::length(&username) <= 66, EDataTooLong);
        User {
            user_wallet,
            version: 0,
            username,
            profile_image,
            bio,
        }
    }

    struct UserCreated has store, drop {
        user_wallet: address,
        username: String,
        profile_image: String,
        bio: String,
    }

    public fun user_created_user_wallet(user_created: &UserCreated): address {
        user_created.user_wallet
    }

    public fun user_created_username(user_created: &UserCreated): String {
        user_created.username
    }

    public fun user_created_profile_image(user_created: &UserCreated): String {
        user_created.profile_image
    }

    public fun user_created_bio(user_created: &UserCreated): String {
        user_created.bio
    }

    public(friend) fun new_user_created(
        user_wallet: address,
        username: String,
        profile_image: String,
        bio: String,
    ): UserCreated {
        UserCreated {
            user_wallet,
            username,
            profile_image,
            bio,
        }
    }

    struct UserUpdated has store, drop {
        user_wallet: address,
        version: u64,
        username: String,
        profile_image: String,
        bio: String,
    }

    public fun user_updated_user_wallet(user_updated: &UserUpdated): address {
        user_updated.user_wallet
    }

    public fun user_updated_username(user_updated: &UserUpdated): String {
        user_updated.username
    }

    public fun user_updated_profile_image(user_updated: &UserUpdated): String {
        user_updated.profile_image
    }

    public fun user_updated_bio(user_updated: &UserUpdated): String {
        user_updated.bio
    }

    public(friend) fun new_user_updated(
        user: &User,
        username: String,
        profile_image: String,
        bio: String,
    ): UserUpdated {
        UserUpdated {
            user_wallet: user_wallet(user),
            version: version(user),
            username,
            profile_image,
            bio,
        }
    }


    public(friend) fun create_user(
        user_wallet: address,
        username: String,
        profile_image: String,
        bio: String,
    ): User acquires Tables {
        asset_user_not_exists(user_wallet);
        let user = new_user(
            user_wallet,
            username,
            profile_image,
            bio,
        );
        user
    }

    public(friend) fun asset_user_not_exists(
        user_wallet: address,
    ) acquires Tables {
        assert!(exists<Tables>(genesis_account::resource_account_address()), ENotInitialized);
        let tables = borrow_global_mut<Tables>(genesis_account::resource_account_address());
        assert!(!table::contains(&tables.user_table, user_wallet), EIdAlreadyExists);
    }

    public(friend) fun update_version_and_add(user: User) acquires Tables {
        user.version = user.version + 1;
        //assert!(user.version != 0, EInappropriateVersion);
        private_add_user(user);
    }

    public(friend) fun add_user(user: User) acquires Tables {
        assert!(user.version == 0, EInappropriateVersion);
        private_add_user(user);
    }

    public(friend) fun remove_user(user_wallet: address): User acquires Tables {
        assert!(exists<Tables>(genesis_account::resource_account_address()), ENotInitialized);
        let tables = borrow_global_mut<Tables>(genesis_account::resource_account_address());
        table::remove(&mut tables.user_table, user_wallet)
    }

    fun private_add_user(user: User) acquires Tables {
        assert!(exists<Tables>(genesis_account::resource_account_address()), ENotInitialized);
        let tables = borrow_global_mut<Tables>(genesis_account::resource_account_address());
        table::add(&mut tables.user_table, user.user_wallet, user);
    }

    public fun get_user(user_wallet: address): pass_object::PassObject<User> acquires Tables {
        let user = remove_user(user_wallet);
        pass_object::new(user)
    }

    public fun return_user(user_pass_obj: pass_object::PassObject<User>) acquires Tables {
        let user = pass_object::extract(user_pass_obj);
        private_add_user(user);
    }

    public(friend) fun drop_user(user: User) {
        let User {
            version: _version,
            user_wallet: _user_wallet,
            username: _username,
            profile_image: _profile_image,
            bio: _bio,
        } = user;
    }

    public fun contains_user(user_wallet: address): bool acquires Tables {
        let tables = borrow_global<Tables>(genesis_account::resource_account_address());
        table::contains(&tables.user_table, user_wallet)
    }

    public(friend) fun emit_user_created(user_created: UserCreated) acquires Events {
        assert!(exists<Events>(genesis_account::resource_account_address()), ENotInitialized);
        let events = borrow_global_mut<Events>(genesis_account::resource_account_address());
        event::emit_event(&mut events.user_created_handle, user_created);
    }

    public(friend) fun emit_user_updated(user_updated: UserUpdated) acquires Events {
        assert!(exists<Events>(genesis_account::resource_account_address()), ENotInitialized);
        let events = borrow_global_mut<Events>(genesis_account::resource_account_address());
        event::emit_event(&mut events.user_updated_handle, user_updated);
    }

}
